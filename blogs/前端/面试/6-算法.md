---
title: 算法
---

# 二叉树

![2405011-5f5b0b136713f744](https://gitee.com/xiaolannuoyi/my_drawing_bed/raw/master/image/2405011-5f5b0b136713f744.jpg)

> 先序：1 2 4 6 7 8 3 5
> 中序：4 7 6 8 2 1 3 5
> 后序：7 8 6 4 2 5 3 1

**先序：**考察到一个节点后，即刻输出该节点的值，并继续遍历其左右子树。(根左右)

**中序：**考察到一个节点后，将其暂存，遍历完左子树后，再输出该节点的值，然后遍历右子树。(左根右)

**后序：**考察到一个节点后，将其暂存，遍历完左右子树后，再输出该节点的值。(左右根)


# 插入算法

>最好情况：数组升序排列，时间复杂度为：O(n)
>
>最坏情况：数组降序排列，时间复杂度为：O(n²)

从第二个元素开始为目标值，（认为她前面的值是有序的）

遍历目标值前面的元素，并与目标值比较

* 如果a r r[j]比目标值大，将此值向后移动一位
* 否则，结束内循环

将目标值放到 j+1 的位置（因为前面有个j--）

```js
function InsertionSort(arr){
    for(let i=1,len=arr.length;i<len;i++){
        let temp = arr[i];
        let j=i-1
        for(;j>=0;j--){
            if(arr[j] < temp)break;
            arr[j+1] = arr[j]
        }
        // arr[j+1] = temp;//可优化成 
        if(j+1!==i)arr[j+1] = temp;
    }
    return arr;
}
```



