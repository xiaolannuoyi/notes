(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{557:function(t,_,v){"use strict";v.r(_);var a=v(4),e=Object(a.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"v8引擎相关"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#v8引擎相关"}},[t._v("#")]),t._v(" v8引擎相关")]),t._v(" "),v("blockquote",[v("p",[t._v("JavaScript就是一种解释型脚本语言，解释型语言一边编译一边执行，很明显解释型语言的执行速度是慢于编译型语言的")])]),t._v(" "),v("h1",{attrs:{id:"浏览器的执行机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#浏览器的执行机制"}},[t._v("#")]),t._v(" 浏览器的执行机制")]),t._v(" "),v("ul",[v("li",[t._v("执行上下文\n"),v("ul",[v("li",[t._v("变量对象/词法环境")]),t._v(" "),v("li",[v("kbd",[t._v("scope")]),t._v("作用域")]),t._v(" "),v("li",[t._v("this")])])]),t._v(" "),v("li",[t._v("执行上下文栈")]),t._v(" "),v("li",[t._v("作用域/闭包")]),t._v(" "),v("li",[t._v("this")])]),t._v(" "),v("h1",{attrs:{id:"内存机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#内存机制"}},[t._v("#")]),t._v(" 内存机制")]),t._v(" "),v("ul",[v("li",[t._v("代码空间")]),t._v(" "),v("li",[t._v("栈空间——基本类型")]),t._v(" "),v("li",[t._v("堆空间——对象")])]),t._v(" "),v("h1",{attrs:{id:"垃圾回收"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收"}},[t._v("#")]),t._v(" 垃圾回收")]),t._v(" "),v("ul",[v("li",[t._v("栈——")]),t._v(" "),v("li",[t._v("堆\n"),v("ul",[v("li",[t._v("新生代——scavenge算法")]),t._v(" "),v("li",[t._v("老生代——标记清除（Mark-Sweep）标记整理。优化（增量标记算法）")])])])]),t._v(" "),v("p",[t._v("标记——清理——整理")]),t._v(" "),v("h1",{attrs:{id:"事件循环机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事件循环机制"}},[t._v("#")]),t._v(" 事件循环机制")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/xiaolannuoyi/my_drawing_bed/raw/master/image/download-1.png",alt:"download-1"}})]),t._v(" "),v("blockquote",[v("p",[t._v("仅仅打开了 1 个页面，为什么有 4 个进程？因为打开 1 个页面至少需要 1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程，共 4 个；如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。")])]),t._v(" "),v("ul",[v("li",[v("p",[t._v("宏任务")]),t._v(" "),v("blockquote",[v("p",[t._v("把异步回调函数封装成一个宏任务，添加到消息队列尾部，当循环系统执行到该任务的时候执行回调函数**。这种比较好理解，我们前面介绍的 setTimeout 和 XMLHttpRequest 的回调函数都是通过这种方式来实现的。")])])]),t._v(" "),v("li",[v("p",[t._v("微任务")]),t._v(" "),v("blockquote",[v("p",[t._v("主函数执行结束之后、当前宏任务结束之前执行回调函数")])])])]),t._v(" "),v("p",[t._v("而宏任务一般是：包括整体代码script，setTimeout，setInterval、setImmediate。")]),t._v(" "),v("p",[t._v("微任务：原生Promise(有些实现的promise将then方法放到了宏任务中)、process.nextTick、Object.observe(已废弃)、 MutationObserver 记住就行了。")]),t._v(" "),v("blockquote",[v("p",[t._v("微任务先于宏任务执行")])]),t._v(" "),v("p",[t._v("promise")]),t._v(" "),v("ul",[v("li",[t._v("消灭嵌套。  ——Promise 通过回调函数延迟绑定和回调函数返回值穿透的技术，解决了循环嵌套。")]),t._v(" "),v("li",[t._v("合并多任务的错误处理—— Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被 onReject 函数处理或 catch 语句捕获为止")])]),t._v(" "),v("p",[t._v("async/await——Generator 和 Promise")]),t._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v('export GOOGLE_API_KEY="AIzaSyD4GcXM7uthMaElgg_BfYBKLsVdrdxBaU0"\nexport GOOGLE_DEFAULT_CLIENT_ID="616196329977-u27q83pdmq9qa78a3mhndn2bf3f74lq9.apps.googleusercontent.com"\nexport GOOGLE_DEFAULT_CLIENT_SECRET="5NKsrN4z3dQNtPC1Bg2HN4Na"\n')])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br"),v("span",{staticClass:"line-number"},[t._v("3")]),v("br")])]),v("h1",{attrs:{id:"垃圾回收-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收-2"}},[t._v("#")]),t._v(" 垃圾回收")]),t._v(" "),v("p",[t._v("基本的垃圾回收算法称为**“标记-清除”**，定期执行以下“垃圾回收”步骤:")]),t._v(" "),v("ul",[v("li",[t._v("垃圾回收器获取根并**“标记”**(记住)它们。")]),t._v(" "),v("li",[t._v("然后它访问并“标记”所有来自它们的引用。")]),t._v(" "),v("li",[t._v("然后它访问标记的对象并标记它们的引用。所有被访问的对象都被记住，以便以后不再访问同一个对象两次。")]),t._v(" "),v("li",[t._v("以此类推，直到有未访问的引用(可以从根访问)为止。")]),t._v(" "),v("li",[t._v("除标记的对象外，所有对象都被删除。")])]),t._v(" "),v("p",[t._v("一些优化:")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("分代回收")]),t._v("——对象分为两组:“新对象”和“旧对象”。许多对象出现，完成它们的工作并迅速结 ，它们很快就会被清理干净。那些活得足够久的对象，会变“老”，并且很少接受检查。")]),t._v(" "),v("li",[v("strong",[t._v("增量回收")]),t._v("——如果有很多对象，并且我们试图一次遍历并标记整个对象集，那么可能会花费一些时间，并在执行中会有一定的延迟。因此，引擎试图将垃圾回收分解为多个部分。然后，各个部分分别执行。这需要额外的标记来跟踪变化，这样有很多微小的延迟，而不是很大的延迟。")]),t._v(" "),v("li",[v("strong",[t._v("空闲时间收集")]),t._v("——垃圾回收器只在 CPU 空闲时运行，以减少对执行的可能影响。")])]),t._v(" "),v("h1",{attrs:{id:"参考文章"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[t._v("#")]),t._v(" 参考文章")]),t._v(" "),v("p",[v("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/27628685",target:"_blank",rel:"noopener noreferrer"}},[t._v("认识 V8 引擎"),v("OutboundLink")],1)]),t._v(" "),v("p",[t._v("https://zhuanlan.zhihu.com/p/60336501")])])}),[],!1,null,null,null);_.default=e.exports}}]);